"""
Indoor Positioning System - Positioning Evaluations Module

–≠—Ç–æ—Ç –º–æ–¥—É–ª—å —Ä–µ–∞–ª–∏–∑—É–µ—Ç –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –¥–ª—è –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –≤ –ø–æ–º–µ—â–µ–Ω–∏–∏.
–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ—Ç ESP32 —è–∫–æ—Ä–µ–π –∏ –≤—ã—á–∏—Å–ª—è–µ—Ç –ø–æ–∑–∏—Ü–∏–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤
"""
"""
Indoor Positioning System - Enhanced Positioning Evaluations Module
"""

import numpy as np
import logging
from typing import Dict, List, Tuple, Optional, Any
from scipy.optimize import minimize
import numpy.linalg as la

logger = logging.getLogger(__name__)


class EnhancedTrilaterationEngine:
    """–£–ª—É—á—à–µ–Ω–Ω—ã–π –¥–≤–∏–∂–æ–∫ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –ø–æ–∑–∏—Ü–∏–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö."""

    def __init__(self, room_config: Dict[str, Any]) -> None:
        self.room_config = room_config

    def calculate_position(self, anchor_measurements: Dict[str, Any]) -> Optional[Dict[str, float]]:
        """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Ä–∞—Å—á–µ—Ç–∞ –ø–æ–∑–∏—Ü–∏–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö."""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ anchor_measurements - —ç—Ç–æ —Å–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏
            if not anchor_measurements or len(anchor_measurements) < 2:
                print(f"‚ö†Ô∏è  Not enough anchor measurements: {len(anchor_measurements)}")
                return None

            print(f"üéØ –ù–∞—á–∞–ª–æ —Ä–∞—Å—á–µ—Ç–∞ –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è {len(anchor_measurements)} —è–∫–æ—Ä–µ–π")

            # –î–µ—Ç–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö
            for anchor_id, measurements in anchor_measurements.items():
                print(f"   üîç Anchor {anchor_id}: {len(measurements)} measurements")
                if not isinstance(measurements, list) or not measurements:
                    print(f"   ‚ö†Ô∏è  Invalid measurements for anchor {anchor_id}: {type(measurements)}")
                    return None

            # –í–∑–≤–µ—à–∏–≤–∞–µ–º –∏–∑–º–µ—Ä–µ–Ω–∏—è –ø–æ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
            weighted_measurements = self._apply_measurement_weights(anchor_measurements)

            if not weighted_measurements:
                print("‚ö†Ô∏è  No valid weighted measurements")
                return None

            print(f"   ‚úÖ Weighted measurements ready: {len(weighted_measurements)} anchors")

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É weighted_measurements
            for anchor_id, data in weighted_measurements.items():
                if not isinstance(data, dict):
                    print(f"   ‚ö†Ô∏è  Invalid weighted data for {anchor_id}: {type(data)}")
                    return None
                print(f"   üìã Weighted data keys for {anchor_id}: {list(data.keys())}")

            # –ü—Ä–æ–±—É–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ —Ä–∞–∑–Ω—ã–µ –º–µ—Ç–æ–¥—ã —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
            position = self.enhanced_trilateration_3d(weighted_measurements)
            if not position or not self.is_valid_position(position):
                print("   üîÑ Trying confidence weighted centroid")
                position = self.confidence_weighted_centroid(weighted_measurements)
            if not position or not self.is_valid_position(position):
                print("   üîÑ Trying adaptive geometric method")
                position = self.adaptive_geometric_method(weighted_measurements)
            if position and not self.is_valid_position(position):
                print("   üîÑ Correcting position")
                position = self.correct_position(position)

            if position:
                # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
                confidence = calculate_enhanced_confidence(weighted_measurements, position, self.room_config)
                print(f"   üéØ Final confidence: {confidence:.2f}")
                position['confidence'] = confidence
                return position
            else:
                confidence = 0.1

            return position

        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –ø–æ–∑–∏—Ü–∏–∏: {e}")
            import traceback
            traceback.print_exc()
            return None

    def _apply_measurement_weights(self, anchor_measurements: Dict[str, Any]) -> Dict[str, Dict[str, Any]]:
        """–ü—Ä–∏–º–µ–Ω—è–µ—Ç –≤–µ—Å–∞ –∫ –∏–∑–º–µ—Ä–µ–Ω–∏—è–º —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π —Ñ–æ—Ä–º—É–ª–æ–π."""
        print(f"   üîç Applying weights to {len(anchor_measurements)} anchor measurements")

        weighted_data = {}

        for anchor_id, measurements in anchor_measurements.items():
            print(f"   üìã Processing anchor {anchor_id}: {len(measurements)} measurements")

            if not measurements or not isinstance(measurements, list):
                print(f"   ‚ö†Ô∏è  No measurements for anchor {anchor_id}")
                continue

            # –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∏–∑–º–µ—Ä–µ–Ω–∏–µ
            latest_measurement = measurements[-1]

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∏–∑–º–µ—Ä–µ–Ω–∏—è
            if not isinstance(latest_measurement, dict):
                print(f"   ‚ö†Ô∏è  Invalid measurement type for anchor {anchor_id}: {type(latest_measurement)}")
                continue

            print(f"   üìù Measurement keys: {list(latest_measurement.keys())}")

            # –ë–∞–∑–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
            distance_confidence = latest_measurement.get('distance_confidence', 0.5)
            packet_count = latest_measurement.get('packet_count', 1)
            channel_consistency = latest_measurement.get('channel_consistency', 0.5)
            rssi_filtered = latest_measurement.get('rssi_filtered', -70)

            # –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è —Ñ–æ—Ä–º—É–ª–∞ –≤–µ—Å–æ–≤
            confidence_weight = distance_confidence * 0.6
            packet_weight = min(1.0, packet_count / 5.0) * 0.3
            channel_weight = channel_consistency * 0.1

            total_weight = confidence_weight + packet_weight + channel_weight
            total_weight = min(1.0, total_weight)

            weighted_data[anchor_id] = {
                'distance': latest_measurement.get('distance', 0),
                'weight': total_weight,
                'confidence': distance_confidence,  # –≠–¢–û –ø–æ–ª–µ –≤–∞–∂–Ω–æ –¥–ª—è calculate_enhanced_confidence!
                'rssi_filtered': rssi_filtered,
                'channel': latest_measurement.get('channel', 1),
                'original_data': measurements  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Å–µ –∏–∑–º–µ—Ä–µ–Ω–∏—è –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            }

            print(f"   ‚úÖ {anchor_id}: weight={total_weight:.2f}, conf={distance_confidence:.2f}")

        print(f"   üìä Created weighted data for {len(weighted_data)} anchors")
        return weighted_data

    def enhanced_trilateration_3d(self, weighted_measurements: Dict[str, Dict[str, Any]]) -> Optional[Dict[str, float]]:
        """–£–ª—É—á—à–µ–Ω–Ω–∞—è 3D —Ç—Ä–∏–ª–∞—Ç–µ—Ä–∞—Ü–∏—è —Å –≤–µ—Å–∞–º–∏ –∏–∑–º–µ—Ä–µ–Ω–∏–π."""
        try:
            if len(weighted_measurements) < 3:
                return None

            print("üìç –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–ª—É—á—à–µ–Ω–Ω—É—é 3D —Ç—Ä–∏–ª–∞—Ç–µ—Ä–∞—Ü–∏—é")

            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å –≤–µ—Å–∞–º–∏
            anchors_list = []
            distances_list = []
            weights_list = []

            for anchor_id, data in weighted_measurements.items():
                if anchor_id in self.room_config['anchors']:
                    anchor = self.room_config['anchors'][anchor_id]
                    anchors_list.append([anchor['x'], anchor['y'], anchor['z']])
                    distances_list.append(data['distance'])
                    weights_list.append(data['weight'])

            # –ú–µ—Ç–æ–¥ –Ω–∞–∏–º–µ–Ω—å—à–∏—Ö –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ —Å –≤–µ—Å–∞–º–∏
            def error_function(pos):
                x, y, z = pos
                total_error = 0.0
                for i, (anchor, dist, weight) in enumerate(zip(anchors_list, distances_list, weights_list)):
                    calculated_dist = np.sqrt((x - anchor[0]) ** 2 + (y - anchor[1]) ** 2 + (z - anchor[2]) ** 2)
                    error = (calculated_dist - dist) ** 2
                    total_error += error * weight
                return total_error

            # –ù–∞—á–∞–ª—å–Ω–æ–µ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ - —Ü–µ–Ω—Ç—Ä –∫–æ–º–Ω–∞—Ç—ã
            initial_guess = [self.room_config['width'] / 2,
                             self.room_config['height'] / 2,
                             self.room_config.get('depth', 5) / 2]

            # –ì—Ä–∞–Ω–∏—Ü—ã –∫–æ–º–Ω–∞—Ç—ã
            bounds = [(0, self.room_config['width']),
                      (0, self.room_config['height']),
                      (0, self.room_config.get('depth', 5))]

            result = minimize(error_function, initial_guess, bounds=bounds, method='L-BFGS-B')

            if result.success:
                position = {
                    'x': float(result.x[0]),
                    'y': float(result.x[1]),
                    'z': float(result.x[2])
                }

                print(f"‚úÖ –£—Å–ø–µ—à–Ω–∞—è —É–ª—É—á—à–µ–Ω–Ω–∞—è 3D —Ç—Ä–∏–ª–∞—Ç–µ—Ä–∞—Ü–∏—è: {position}")
                return position

            return None

        except Exception as e:
            print(f"–£–ª—É—á—à–µ–Ω–Ω–∞—è 3D —Ç—Ä–∏–ª–∞—Ç–µ—Ä–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å: {e}")
            return None

    def confidence_weighted_centroid(self, weighted_measurements: Dict[str, Dict[str, Any]]) -> Optional[
        Dict[str, float]]:
        """–ú–µ—Ç–æ–¥ –≤–∑–≤–µ—à–µ–Ω–Ω–æ–≥–æ —Ü–µ–Ω—Ç—Ä–∞ —Å —É—á–µ—Ç–æ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏ –∏–∑–º–µ—Ä–µ–Ω–∏–π."""
        try:
            print("üìç –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–µ—Ç–æ–¥ –≤–∑–≤–µ—à–µ–Ω–Ω–æ–≥–æ —Ü–µ–Ω—Ç—Ä–∞ —Å —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å—é")

            total_weight = 0
            x_sum, y_sum, z_sum = 0, 0, 0

            for anchor_id, data in weighted_measurements.items():
                if anchor_id in self.room_config['anchors']:
                    anchor = self.room_config['anchors'][anchor_id]
                    weight = data['weight']

                    # –£—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –≤ –≤–µ—Å–µ (–±–ª–∏–∑–∫–∏–µ —è–∫–æ—Ä—è –∏–º–µ—é—Ç –±–æ–ª—å—à–∏–π –≤–µ—Å)
                    distance_weight = 1.0 / (data['distance'] + 0.1)

                    # –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤–µ—Å
                    combined_weight = weight * distance_weight

                    x_sum += anchor['x'] * combined_weight
                    y_sum += anchor['y'] * combined_weight
                    z_sum += anchor['z'] * combined_weight
                    total_weight += combined_weight

            if total_weight > 0:
                x = x_sum / total_weight
                y = y_sum / total_weight
                z = z_sum / total_weight

                # –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è –≤—ã—Å–æ—Ç—ã
                z = self._estimate_enhanced_z_coordinate(x, y, weighted_measurements)

                result = {'x': x, 'y': y, 'z': z}
                print(f"‚úÖ –ú–µ—Ç–æ–¥ –≤–∑–≤–µ—à–µ–Ω–Ω–æ–≥–æ —Ü–µ–Ω—Ç—Ä–∞: {result}")
                return result

            return None

        except Exception as e:
            print(f"–ú–µ—Ç–æ–¥ –≤–∑–≤–µ—à–µ–Ω–Ω–æ–≥–æ —Ü–µ–Ω—Ç—Ä–∞ –Ω–µ —É–¥–∞–ª—Å—è: {e}")
            return None

    def adaptive_geometric_method(self, weighted_measurements: Dict[str, Dict[str, Any]]) -> Optional[Dict[str, float]]:
        """–ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥ —Å —É—á–µ—Ç–æ–º –∫–∞—á–µ—Å—Ç–≤–∞ –∏–∑–º–µ—Ä–µ–Ω–∏–π."""
        try:
            print("üîÑ –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥")

            if len(weighted_measurements) < 2:
                return None

            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –∏–∑–º–µ—Ä–µ–Ω–∏—è –ø–æ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
            sorted_measurements = sorted(
                weighted_measurements.items(),
                key=lambda x: x[1]['weight'],
                reverse=True
            )

            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–≤–∞ –Ω–∞–∏–±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω—ã—Ö –∏–∑–º–µ—Ä–µ–Ω–∏—è –¥–ª—è –Ω–∞—á–∞–ª—å–Ω–æ–π –æ—Ü–µ–Ω–∫–∏
            best_measurements = sorted_measurements[:2]

            circles = []
            for anchor_id, data in best_measurements:
                if anchor_id in self.room_config['anchors']:
                    anchor = self.room_config['anchors'][anchor_id]
                    circles.append({
                        'center': (anchor['x'], anchor['y']),
                        'radius': data['distance'],
                        'weight': data['weight']
                    })

            if len(circles) >= 2:
                # –ù–∞—Ö–æ–¥–∏–º —Ç–æ—á–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –¥–≤—É—Ö –Ω–∞–∏–±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω—ã—Ö –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–µ–π
                intersections = self._find_circle_intersections(
                    circles[0]['center'], circles[0]['radius'],
                    circles[1]['center'], circles[1]['radius']
                )

                if intersections:
                    # –í—ã–±–∏—Ä–∞–µ–º —Ç–æ—á–∫—É, –±–ª–∏–∂–∞–π—à—É—é –∫ –¥—Ä—É–≥–∏–º —è–∫–æ—Ä—è–º
                    best_point = self._select_best_intersection(intersections, weighted_measurements)
                    z = self._estimate_enhanced_z_coordinate(best_point[0], best_point[1], weighted_measurements)

                    result = {'x': best_point[0], 'y': best_point[1], 'z': z}
                    print(f"‚úÖ –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥: {result}")
                    return result

            return None

        except Exception as e:
            print(f"–ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥ –Ω–µ —É–¥–∞–ª—Å—è: {e}")
            return None

    def _estimate_enhanced_z_coordinate(self, x: float, y: float,
                                        weighted_measurements: Dict[str, Dict[str, Any]]) -> float:
        """–£–ª—É—á—à–µ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ Z-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å —É—á–µ—Ç–æ–º –∫–∞—á–µ—Å—Ç–≤–∞ –∏–∑–º–µ—Ä–µ–Ω–∏–π."""
        try:
            total_weight = 0
            z_weighted = 0

            for anchor_id, data in weighted_measurements.items():
                if anchor_id in self.room_config['anchors']:
                    anchor = self.room_config['anchors'][anchor_id]
                    weight = data['weight']

                    # –£—á–∏—Ç—ã–≤–∞–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —è–∫–æ—Ä—è
                    horizontal_dist = np.sqrt((x - anchor['x']) ** 2 + (y - anchor['y']) ** 2)
                    distance_ratio = data['distance'] / (horizontal_dist + 0.1)

                    # –û—Ü–µ–Ω–∏–≤–∞–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É—é –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—É
                    if data['distance'] > horizontal_dist:
                        z_diff = np.sqrt(data['distance'] ** 2 - horizontal_dist ** 2)
                        estimated_z = anchor['z'] + z_diff
                    else:
                        estimated_z = anchor['z']

                    z_weighted += estimated_z * weight
                    total_weight += weight

            avg_z = z_weighted / total_weight if total_weight > 0 else 1.5

            # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º based –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏ –∏ –∫–∞—á–µ—Å—Ç–≤–µ –∏–∑–º–µ—Ä–µ–Ω–∏–π
            close_to_wall = (x < 2.0 or x > self.room_config['width'] - 2 or
                             y < 2.0 or y > self.room_config['height'] - 2)

            if close_to_wall:
                z_estimate = max(0.3, avg_z * 0.7)
            else:
                z_estimate = min(2.5, max(1.0, avg_z))

            z_estimate = max(0.3, min(3.0, z_estimate))
            print(f"   üìä –£–ª—É—á—à–µ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ Z: {z_estimate:.2f}m")
            return z_estimate

        except Exception as e:
            print(f"   ‚ö†Ô∏è  –û—à–∏–±–∫–∞ —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ—Ü–µ–Ω–∫–∏ Z: {e}")
            return 1.5

    def _find_circle_intersections(self, center1, radius1, center2, radius2):
        """–ù–∞—Ö–æ–¥–∏—Ç —Ç–æ—á–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –¥–≤—É—Ö –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–µ–π."""
        x1, y1 = center1
        x2, y2 = center2
        r1, r2 = radius1, radius2

        # –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —Ü–µ–Ω—Ç—Ä–∞–º–∏
        d = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
        if d > r1 + r2 or d < abs(r1 - r2):
            return None

        # –í—ã—á–∏—Å–ª–µ–Ω–∏—è —Ç–æ—á–µ–∫ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
        a = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d)
        h = np.sqrt(r1 ** 2 - a ** 2)

        xm = x1 + a * (x2 - x1) / d
        ym = y1 + a * (y2 - y1) / d

        xs1 = xm + h * (y2 - y1) / d
        xs2 = xm - h * (y2 - y1) / d
        ys1 = ym - h * (x2 - x1) / d
        ys2 = ym + h * (x2 - x1) / d

        return [(xs1, ys1), (xs2, ys2)]

    def _select_best_intersection(self, intersections, weighted_measurements):
        """–í—ã–±–∏—Ä–∞–µ—Ç –ª—É—á—à—É—é —Ç–æ—á–∫—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥—Ä—É–≥–∏—Ö –∏–∑–º–µ—Ä–µ–Ω–∏–π."""
        if len(intersections) == 1:
            return intersections[0]

        # –û—Ü–µ–Ω–∏–≤–∞–µ–º –∫–∞–∂–¥—É—é —Ç–æ—á–∫—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
        best_score = float('inf')
        best_point = intersections[0]

        for point in intersections:
            score = 0
            for anchor_id, data in weighted_measurements.items():
                if anchor_id in self.room_config['anchors']:
                    anchor = self.room_config['anchors'][anchor_id]
                    calculated_dist = np.sqrt(
                        (point[0] - anchor['x']) ** 2 +
                        (point[1] - anchor['y']) ** 2
                    )
                    error = abs(calculated_dist - data['distance'])
                    score += error * data['weight']

            if score < best_score:
                best_score = score
                best_point = point

        return best_point

    def is_valid_position(self, position: Dict[str, float]) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –ø–æ–∑–∏—Ü–∏—è –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –∫–æ–º–Ω–∞—Ç—ã."""
        x, y, z = position['x'], position['y'], position['z']
        valid = (0 <= x <= self.room_config['width'] and
                 0 <= y <= self.room_config['height'] and
                 0 <= z <= 4.0)

        if not valid:
            print(f"‚ö†Ô∏è  –ü–æ–∑–∏—Ü–∏—è –≤–Ω–µ –∫–æ–º–Ω–∞—Ç—ã: ({x:.2f}, {y:.2f}, {z:.2f})")

        return valid

    def correct_position(self, position: Dict[str, float]) -> Dict[str, float]:
        """–ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ—Ç –ø–æ–∑–∏—Ü–∏—é —á—Ç–æ–±—ã –æ–Ω–∞ –±—ã–ª–∞ –≤–Ω—É—Ç—Ä–∏ –∫–æ–º–Ω–∞—Ç—ã."""
        x = max(0.5, min(self.room_config['width'] - 0.5, position['x']))
        y = max(0.5, min(self.room_config['height'] - 0.5, position['y']))
        z = max(0.5, min(3.0, position['z']))

        corrected = {'x': x, 'y': y, 'z': z}
        print(f"   üìç –°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è: {corrected}")
        return corrected


def calculate_enhanced_confidence(weighted_measurements: Dict[str, Dict[str, Any]],
                                  position: Dict[str, float],
                                  room_config: Dict[str, Any] = None) -> float:
    """–£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –∏ –Ω–∞–¥–µ–∂–Ω—ã–π —Ä–∞—Å—á–µ—Ç —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏."""
    try:
        if not weighted_measurements:
            return 0.1

        print(f"   üîç Confidence calculation for {len(weighted_measurements)} anchors")

        # 1. –ë–∞–∑–æ–≤–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —è–∫–æ—Ä–µ–π
        anchor_count = len(weighted_measurements)
        if anchor_count >= 4:
            base_confidence = 0.8
        elif anchor_count == 3:
            base_confidence = 0.7
        elif anchor_count == 2:
            base_confidence = 0.5
        else:
            base_confidence = 0.2

        # 2. –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ confidence –∏–∑ weighted_measurements
        all_confidences = []
        for anchor_id, data in weighted_measurements.items():
            # data –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å–ª–æ–≤–∞—Ä–µ–º —Å –ø–æ–ª–µ–º 'confidence'
            if isinstance(data, dict):
                confidence = data.get('confidence', 0.5)
                all_confidences.append(confidence)
                print(f"   üìä Anchor {anchor_id}: confidence={confidence:.2f}")
            else:
                print(f"   ‚ö†Ô∏è  Invalid data type for anchor {anchor_id}: {type(data)}")
                all_confidences.append(0.3)  # default

        # 3. –°—Ä–µ–¥–Ω—è—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –∏–∑–º–µ—Ä–µ–Ω–∏–π
        if all_confidences:
            avg_measurement_confidence = np.mean(all_confidences)
        else:
            avg_measurement_confidence = 0.5

        # 4. –ü—Ä–æ—Å—Ç–∞—è —Ñ–æ—Ä–º—É–ª–∞: —Å—Ä–µ–¥–Ω–µ–µ –º–µ–∂–¥—É –±–∞–∑–æ–≤–æ–π –∏ —Å—Ä–µ–¥–Ω–µ–π —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å—é –∏–∑–º–µ—Ä–µ–Ω–∏–π
        total_confidence = (base_confidence + avg_measurement_confidence) / 2

        # 5. –ë–æ–Ω—É—Å—ã
        bonus = 1.0

        # –ë–æ–Ω—É—Å –∑–∞ –≤—ã—Å–æ–∫—É—é —Å—Ä–µ–¥–Ω—é—é —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –∏–∑–º–µ—Ä–µ–Ω–∏–π
        if avg_measurement_confidence > 0.7:
            bonus *= 1.1

        # –ë–æ–Ω—É—Å –∑–∞ –º–Ω–æ–≥–æ —è–∫–æ—Ä–µ–π
        if anchor_count >= 3:
            bonus *= 1.1

        total_confidence *= bonus
        total_confidence = max(0.1, min(1.0, total_confidence))

        print(f"   üéØ Confidence: base={base_confidence:.2f}, "
              f"measurements={avg_measurement_confidence:.2f}, "
              f"bonus={bonus:.2f}, total={total_confidence:.2f}")

        return total_confidence

    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏: {e}")
        import traceback
        print(f"   Traceback: {traceback.format_exc()}")
        return 0.5